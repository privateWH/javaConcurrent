javaConcurrent
==============

java concurrent

Data Structure
   Flat file to Data Structure
   Data Structure to Scaled Algorithm to preserve data structure property.
   
Design Pattern
  Schema File to Java File. Java File to Jar file. 
  Versioning Java Model.
  Design Pattern

Statistical Model
   Subscription between Data Structure and Statistical Information. (Avg, Cardinality, Perserving Order, etc)
   
Concurrency Support
  Concurrent Safety.
  IO or Execution Bonded Structure.

Object to DB Reduction. ProxyHandler



What I really care.
Dummy
   1. Preserve mixtures by automatic tunning of the following attributes:
        Preserve by time. 
            Inject data to (arbitary|specific) storage host. 
            Inject data to storage host but expires at certain time (borrowed from memcache), expire by KEY values filters or whatever. i.e. FILTER ONLY KEYS with UNIX TIMESTAMP after 0 less than 4. (fusing the procedural with functional language example).
            Preserve by storage type. like the caching hierachy.
   Forcable or not of each parameter.
        
            Don't really care about fancy sets operation for the following reason.
                 still need to do loops when perform whole set. still need to lookup keys for union, intersection operations.
                 However, we should be able to choose any language of expression say from popular Python or R or Matlab or Mathematica or SPSS for example to have the language to convert to an algorithm that can be EXPLAINED. this is crucial for what I want to build. when its explainable in the algorithm then it can be CHANGE. this I think is what I want in a distributed computing language. for each breakdown of operations we can choose when to have performances and signals to trigger INTELLIGENT choices. and the point of INCEPTION to convert into an OPTIMIZATION problem. but that just for algorithmtic pleasure.
                 
 
        
   2. Retrieve mixture by automatic tunning.
      This is going to be interesting because you can have plain text or structural text that adds foramtting. However a picture worth thousand words and a movie or sound might be a different story. and other sensational or not receptor like pressure, heat, waves, atoms. Those can be expressed or manipulated as the product of retrival (similarly with preserving). But in essences, This types of Retrieve should have its own algorithmic process and substition (FAKING it vs REAL) for shortcuts or interpetational sick, after we need to be able to understand it to make sense. but if doesn't make sense that's fine. save the algorithm (someone should remember all the algorithm that already know, so only the cool part gets to added in addition to the old algorithms) save time for other HUMAN to try it next time..
 
   
 Complicated:
   1. Automatic computes the best time for package agreement (protocol vs payload). i.e.:
      {"yes":"good"}. <yes>Internet Explorer</yes>
      the protocol is json or xml
      but it can strip out and left with:
      yes|good,yes:Internet Explorer.
      the possbility are endless you can try.
      protocol:yes:4,yes:EOF
      then payload become good, Internet Explorer.
      further down the line compression come make it even better.
      yes{go2d,Int(er)^e Explor2e. This is hard to deciper it just moment of impulsive encoding of say go(repeat 2 times in char type)d, and Int(er) repeated and insert e in the middle. Anyway, any encoding can happen to make this the best but we can constraint the time and package agreement to compute a value that make this the best, maybe for retrival maybe for permanted storage. 
  
  2. After handled the best package agreement. I want the abilities to calculate the storage cost and time that it took to reconstruct semantic meaningful data.
  
 Notification:Watch and Monitor Change. at a time, in conditions of various variables.
  
        
